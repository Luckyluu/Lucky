# 入门

## 命名空间

命名空间用于区分不同的库中相同名称的函数、类或变量等。使用了命名空间相当于定义了一个范围。 

**使用：**

```c++
//定义 
namespace 名称 {
	//代码声明
}

//调用带有命名空间的变量或函数
name::code; //code为变量或函数

//指定命名空间，在后续使用时不需加上名称
using namespace name;

//指定命名空间的项目，例如使用std中的cout，后续使用cout不必加上std，但是std中的其他项目时仍需加上std
using std::cout;
```





## 函数重载

函数重载是同一个作用域中的某个函数的多个定义，函数名相同。

参数列表必须不同（个数|类型|顺序）

返回类型不做要求

**作用：**常用来处理实现功能类似数据类型不同的问题，减少了函数名的数量，增加程序的可读性。

**为什么C不支持：**

在编译.c文件时，编译器只会给函数进行简单的重命名，就是在函数名前面加上“_”，当两个函数重名时，在编译之后并无差别。

在.cpp文件中，编译器会在函数名后面加上根据参数列表生成的符号，根据不同的符号来区分函数。



## 引用

**定义：**是某个已存在的对象的别名，对引用的操作相当于对对象的操作。

**语法：**类型 & 引用名 = 变量名；  引用和变量指向相同的内存单元

**注意：**

- 引用的类型要与绑定的对象的类型相同
- 声明引用时必须初始化
- 已有的引用不能再作为其他对象的名字或引用
- 引用不是一个新的变量，所以系统不会为其开辟内存空间

**应用：**

1. 作为参数

   ```c++
   void swap(int & x, int & y){
   	int p = x;
   	y = x;
   	x = p;
   }
   ```

   - 与传递指针效果一样，在被调函数中对形参变量的操作就是对实参的操作
   - 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效 率和所占空间都好。
   - 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"***指针变量名**"的 形式进行运算，这很容易产生错误且程序的阅读性较差。

2. 常引用

   如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。

   ```c++
   const 类型 & 引用名 = 变量名;
   ```

3. 引用作为返回值

   - 定义函数时，在函数名前面加上&
   - 用引用返回函数值的好处是在内存中不会产生被返回值得副本。

   规则：

   - 不能返回局部变量的引用。局部变量会在函数返回后被销毁，因此引用就变成了无所指的引用，程序会进入未知状态。

   - 不能返回函数内部new分配的内存的引用。因为被返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间就无法释放。

   - 可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常 量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。

     

## 指针

### 指针和引用的区别

**用指针的使用经常犯得错：**

1. 操作空指针

2. 操作野指针

3. 不知不觉改变了指针的值，而后还以为该指针正常。

   如果我们要正确的使用指针，我们不得不人为地保证这三个条件。而引用的提出就解决了这个问题。

**引用区别于指针的特性是 ：**

1. 不存在空引用（保证不操作空指针）

2. 必须初始化（保证不是野指针）

3. 一个引用永远指向他初始化的那个对象（保证指针值不变）。人为保证变为了编译器来保证，更加安全。

   

## const限定符

const对象一旦创建后，其值就不能再改变。除了不能改变对象的值，其他普通对象能进行的操作，const类型的对象基本都能完成。

默认状态下，const对象仅在文件内有效。要想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。	

### const的引用

把引用绑定到const对象上，为对常量的引用。但是不能通过引用修改它所绑定的对象。

```C++
const int ci = 1024;
const int &r1 = ci; //正确
r1 = 0; //错误
int &r2 = ci; //错误，非常量引用不能绑定常量对象
```

## static关键字

static用于控制变量的存储方式和可见性。

### 1.引入

在函数内部定义的变量，当程序执行到它定的义处时，编译器为它在**栈**上分配空间，在此函数执行结束时就会释放掉。要想将该变量的值保存至下一周期，如何实现？
使用全局变量？会破坏此变量的访问范围。
引入static关键字。

### 2.静态数据的存储

全局（静态）存储区分为DATA段和BSS段。程序结束运行时自动释放。
DATA段：存放**初始化**的全局变量和静态变量
BSS段：存放**未初始化**的全局变量和静态变量（程序执行之前会被系统自动初始化为0）

静态数据成员按定义出现的先后顺序依次初始化，嵌套时，要保证所嵌套的成员已经初始化。消除时的顺序是初始化的反顺序。

优势：节省内存，静态数据成员是所有对象公有的，只存储一处，供所有对象使用。

### 3.static的作用

1. static修饰的**静态局部变量**只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。
2. static修饰的**全局变量**，只能在本文件中访问，不能在其他文件中访问，即便是extern外部声明也不可以。
3. static修饰的**函数**，只能在本文件中调用，不能被其他文件调用。
4. 不想被释放的时候，可以用static修饰。比如函数中存放在栈空间的变量或数组，如果不想让它们在函数调用结束时被释放，可以使用static修饰。
5. 数据安全性

### 4.静态变量与普通变量

静态全局变量的特点：

1. 静态变量都在全局数据区分配内存，包括静态局部变量；
2. 未经初始化的静态全局变量会被程序自动初始化为0；
3. 静态全局变量在声明它的整个文件都是可见的，文件外不可见；其他文件有同名的变量时不会冲突。

静态局部变量的特点：

1. 该变量在全局数据区分配内存；
2. 在程序执行到该对象的声明处时首次被初始化，在以后的函数调用不再进行初始化；
3. 如果没有显式的初始化，会被程序自动初始化为0；
4. 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域。

全局变量和静态全局变量的区别：

1. 全局变量是**不显式**用static修饰的变量，作用域是整个工程。在一个文件内定义的全局变量，在另一个文件中，通过extern修饰，就可以使用。
2. 静态全局变量是**显式**用static修饰的变量，作用域是所在的文件内部。其他文件即使使用extern声明也不能使用。

程序把新产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间。

### 5.static用法

























