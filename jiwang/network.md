



# HTTP

## 一、HTTP基本知识

### HTTP是什么

HTTP是超文本传输协议，它可以拆分成三个部分：超文本、传输、协议

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlU4cfNS4t8C0AjG8YleW3FjITV4h4aQNn1iboHhjALOGicsFsLuQAXwVaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

1. 协议

   HTTP是用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。

2. 传输

   HTTP是一个双向协议，我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。

   ![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUZzUNhbz8lJy4NPLT3iaFFU09Wg5OcrHwXLYP8a1pmaBseMLKxJd7cLw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   HTTP是一个在计算机世界里专门用来在**两点之间传输数据**的约定和规范。

3. 超文本

   文字、图片、视频等的混合体。HTML是最常见的超文本，本身为纯文字，但是内部用很多标签定义了图片，视频，音频等的连接，经过浏览器的解释，呈现给我们的就是我们平时上网看到的效果了。

**定义：**HTTP是一个在计算机世界里面专门在**两点**之间**传输**文字、图片、音频、视频等**超文本**数据的**约定和规范**。

### HTTP常见的状态码

- 1xx：**提示信息**，表示目前是协议处理的中间状态。

  100：客户端应继续其请求。

- 2xx：**成功**，报文已经收到并被正确处理。

  | 状态码 | 英文名称        | 解释                                                         |
  | ------ | --------------- | :----------------------------------------------------------- |
  | 200    | OK              | 一切正常，如果是非HEAD请求，服务器返回的相应头都会有内容     |
  | 204    | No Content      | 服务器成功处理，但未返回内容。在未更新网页的情况下，确保浏览器继续显示当前文档 |
  | 206    | Partial Content | 应用于HTTP分块下载或断电续传，表示响应返回的数据并不是资源的全部，而是其中一部分 |

- 3xx：**重定向**，表示客户端请求的资源发生了变动，需要客户端用新的url重新发送请求获取资源。

  | 状态码 | 英文名称          | 解释                                                         |
  | ------ | ----------------- | ------------------------------------------------------------ |
  | 301    | Moved Permanently | 永久重定向，说明请求的资源已经不存在了，需要改动新的url再次访问 |
  | 302    | Found             | 临时重定向，表示资源还在，但是暂时需要用另一个url来访问<br />301和302都会在响应头里使用字段Location，指明后续要跳转的url，浏览器会自动重定向新的url |
  | 304    | Not Modified      | 不具有跳转意义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制 |

- 4xx：表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

  | 状态码 | 英文名称    | 解释                                                         |
  | ------ | ----------- | ------------------------------------------------------------ |
  | 400    | Bad Request | 表示客户端请求的报文有误，但只是个笼统的错误                 |
  | 403    | Forbidden   | 表示服务器禁止访问资源，并不是客户端的请求出错               |
  | 404    | Not Found   | 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端 |

- 5xx：表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

  | 状态码 | 英文名称              | 解释                                                         |
  | ------ | --------------------- | ------------------------------------------------------------ |
  | 500    | Internal Server Error | 与400类似，是个笼统的错误                                    |
  | 501    | Not Implemented       | 表示客服端请求的功能还不支持                                 |
  | 502    | Bad Gateway           | 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误 |
  | 503    | Service Unavailable   | 表示服务器当前很忙，暂时无法响应客服端的请求                 |

  

### HTTP常见字段

- Host：客户端发送请求时，用来指定服务器的**域名**。有了Host字段，就可以将请求发往**同一台**服务器上的不同网站。

- Content-Length：服务器返回数据时，表明本息回应的数据的长度。（单位：字节）

- Connection：用于客户端要求服务器使用TCP持久连接，以便其他请求复用。

  HTTP/1.1 版本默认连接都是持久连接，但为了兼容老版本的HTTP，需要指定Connection首部字段的值**Connection：keep-alive**，知道客服端或服务器主动关闭连接。

- Connect-Type：用于服务器回应时，向客户端表明数据格式。

  ```C++
  Connect-Type:text/html; charset=tuf-8
      //表明发送的是网页，编码是utf-8
  ```

- Accept：客户端请求时，声明自己可以接受哪些数据格式。Accept：* / * 表明自己可以接受任何格式的数据。

- Connect-Encoding：表示服务器返回的数据使用了什么压缩格式。

- Accept-Encoding：客户端在请求时说明自己可以接受哪些压缩方法。

  

## 二、GET与POST

**GET：**请求葱服务器获取资源。这个资源可以是文本、页面、图片视频等。

例如点开一个文章，浏览器就会发送GET请求给服务器，服务器就会返回文章的所有文字及资源。

**POST：**它是向URI指定的资源提交数据，数据就放在报文的body里。

例如在一篇文章下留言，提交之后浏览器就会执行一次POST请求，把我们的留言放在body里，然后拼接好POST的请求头，通过TCP协议发送给服务器。

GET和POST是HTTP协议中的两种请求方式，而HTTP的底层是TCP/IP，所以GET和POST用的都是同一传输层的协议。



### GET和POST的安全性和幂等

| 安全                     | GET                                                          | POST                                                 |
| ------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- |
| 会不会破坏服务器上的资源 | 不会。GET是只读操作，无论操作多少次，服务器上的数据都是安全的。 | 会。POST是新增或提交数据操作，会修改服务器上的资源。 |
| 传送的数据的位置         | 放在url中，隐私信息可以直接被第三方看到。                    | 放在request body里，对用户不可见                     |

url的长度受浏览器和服务器的限制，所以GET传送的数据量会受到限制。

如果使用GET服务，并且在request body里写入数据，不同的服务器处理方式不同，有些服务器会读出数据，而有些会直接忽略。所以虽然GET可以带request body数据，但是不能保证会被收到。

**幂等：**意思是多次执行相同的操作，结果都是相同的。

所以 GET方案就是幂等的，而POST不是幂等的。

### 产生数据包

GET请求：浏览器会把http header 和打他一并发送出去，服务器响应200 ok；

POST请求：浏览器先发送header，服务器响应100 continue；浏览器再发送data，服务器响应200 ok。



## 三、HTTP特性

### 优点

1. 简单

   HTTP基本的报文格式是header+body，头部信息也是key-value简单文本的形式，易于理解，降低了学习的使用的门槛。

2. 灵活与易于扩展

   HTTP协议里的各类请求方法、URL/URI、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。
   同时HTTP由于是工作在应用层，则它的下层可以随意变化。

3. 应用广泛和跨平台

   从台式机的浏览器到手机上的各种app，从看新闻到刷贴吧到购物，玩游戏等等，HTTP的应用非常广泛，且具有跨平台的优越性。

### 缺点

1. 无状态双刃剑

   **好处：**因为服务器不会去记忆HTTP的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的CPU和内存用来对外援提供服务。

   **坏处：**服务器没有记忆能力，那么在完成有关联性的操作时会比较麻烦。
   例如登录->添加购物车->下单->结算->支付。这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。

   **解决方案：**例如Cookie技术。
   Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态，相当于客户端第一次请求后，服务器会生产Cookie记住客户端是谁，并在响应中添加Cookie；后续客户端请求服务器的时候带上Cookie，服务器就能认识了。

2. 明文传输双刃剑

   **好处：**明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器F12控制台或Wires hark抓包都可以肉眼查看，为我们条调试工作带来了极大的便利。

   **坏处：**在传输的过程中，信息的内容都毫无隐私可言，很容易就能被窃取。

3. 不安全

   - 通信使用明文传输（不加密），内容可能会被窃取，账号信息容易泄露
   - 不验证通信方的身份，因此有可能遭遇伪装。比如访问了假的购物网站，那你钱没了。
   - 无法证明报文的完整性，所以有可能已遭篡改。比如网页上的垃圾广告。

   HTTP的安全问题，可以用HTTPS的方式解决，也就是通过引入SSL/TLS层。

   

## 四、HTTP与HTTPS

### 区别

1. HTTP信息是明文传输，存在安全风险。HTTP在TCP和HTTP之间加入了SSL/TLS安全协议，使得报文能够加密传输。
2. HTTP连接建立相对简单，TCP三次握手之后便可以进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需要进行SSL/TLS的握手过程，才可以进入加密报文传输。
3. HTTP端口号是80，HTTPS端口号是443。
4. HTTPS需要向CA（证书权威机构）申请数字证书，来保证服务器身份是可信的。

### HTTPS如何解决HTTP不安全的问题

1. 混合加密

   实现信息的机密性，解决了窃听的风险。

   混合加密：**对称加密**和**非对称加密**结合。

   - 在通信建立前采用**非对称加密**的方式交换**会话密钥**，后续就不再使用非对称加密。
   - 在通信过程中全部使用**对称加密**的**会话密钥**的方式加密明文数据。

   采用混合加密方式的原因：

   - 对称加密只是用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
   - 非对称加密使用两个密钥：公钥和私钥。公钥可以任意分发，而私钥保密，解决了密钥交换，但速度较慢。

2. 摘要算法

   用于校验数据的完整性，防止被篡改。

   客户端在发送明文之前会通过摘要算法算出明文的“指纹”，发送的时候把“指纹+明文”一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出送过来的明文。通过比较客户端携带的“指纹”和当前算出的“指纹”作比较，若相同则说明数据是完整的。

3. 数字证书

   将服务器公钥放入到数字证书中，解决了冒充的风险。

   客户端先向服务器索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

   **如何保证公钥不被篡改？**

   借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

### HTTPS如何建立连接

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥

- 双方协商产生“会话密钥”

- 双方采用“会话密钥”进行加密通信

  前两步为SSL/TLS 的握手阶段



## 五、HTTP/1.1、HTTP/2、HTTP/3 演变

### HTTP/1.1的性能

HTTP协议是基于TCP/IP，并且使用了“请求-应答”的通信模式。

1. 长连接

   早期HTTP/1.0，每发起一个请求，都要新建立一次TCP连接（三握手），而且是串行请求，做了无谓的TCP连接建立和断开，增加了通信的开销。

   HTTP/1.1提出了**长连接**的通信方式，也叫持久连接，**只要任意一端没有明确提出断开连接，则保持TCP连接状态**。减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器的负载。

2. 管道网络传输

   可以在同一个TCP连接里，客户端可以发起多个请求，只要第一个请求发出去了，不必等待响应，就可以发送第二个请求，可以减少整体响应时间。
   
3. 队头阻塞

   虽然允许浏览器同时发出多个请求，但是服务器还是按照顺序做出回应。当顺序发送的请求序列中的一个请求因为某种元婴被阻塞时，在后面排队的所有请求也一同被阻塞了，会导致客户端一直请求不到数据。

HTTP/1.1瓶颈：

- 请求/响应 头部未经压缩就发送，首部信息越多，延迟越大。只能压缩body部分；
- 发送冗余的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器是按顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据。（队头阻塞）
- 没有请求优先级控制；
- 请求只能从客户端开始，服务器只能被动响应。

### HTTP/2对HTTP/1.1的优化

HTTP/2基于HTTPS，故安全性有保障。

1. 头部压缩

   如果同时发出多个请求，他们的头部是一样的或是相似的，那么协议会消除重复部分。
   HPACK算法：在客户端和服务器同时维护一张头信息表，所有的字段都存在表里，生成一个索引号，以后不发送同样的字段，只需发送索引号即可。

2. 二进制格式

   HTTP/1.1报文为纯文本形式，而HTTP/2采用了二进制格式，头部和数据都是二进制，统称为帧：头信息帧和数据帧。帧是HTTP/2数据通信的最小单位消息。

3. 数据流

   每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号，规定客户端发出的数据流编号为奇数，服务器为偶数。HTTP/2的数据包可以乱序，根据帧首部的标识可以重新组装。
   客户端还可以指定流的优先级。优先级高的请求，服务器就优先响应。

4. 多路复用

   HTTP/1.0中如果想要发多个请求，就必须使用多个TCP连接，且浏览器为了控制资源，还会对单个域名有TCP连接请求限制，如果超过限制就会被挂起等待一段时间。

   HTTP/1.1长连接默认开启keep-alive，解决了上面说到的问题，但是HTTP的传输形式是一问一答的形式，一个请求对应一个响应，必须等下上一个请求接受才能发起下一个请求，所以会收到前面请求的阻塞。

   多路复用代替原来的序列和阻塞机制，所有请求都是通过一个TCP连接并发完成。
   例如：在一个TCP连接里，服务器收到了客户端A和B的两个请求，如果发现A处理过程非常耗时，于是就先回应A请求已经处理好的部分，接着回应B请求，完成后，再回应A请求剩下的部分。

   有了二进制分帧后，HTTP/2不再依靠TCP连接实现多流并行：

   - 同域名下所有通信都在单个连接上完成
   - 单个连接可以承载任意数量的双向数据流
   - 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，根据帧首部的流表示重新组装

   性能提升：

   - 同个域名只需占用一个TCP连接，消除了因多个连接而带来的延时和内存消耗
   - 单个连接上可以并行的请求和响应，之间互不干扰
   - 每个请求都有一个31bit的优先值，0表示最高优先级。服务器和客户端可以以最优的方式发送流、消息。帧。

5. 服务器推送

   服务器可以在发送页面HTML时主动推送其他资源，而不用等到浏览器解析到相应位置发起请求后再响应。例如服务器可以主动把JS、CSS文件等静态资源发给客户端。

### HTTP/3对HTTP/2的优化

**HTTP/2的缺陷**
多个HTTP请求在复用一个TCP连接，下层的TCP协议不知道有多少个HTTP请求。一旦发生丢包现象，就会触发TCP重传机制，这样在同一个TCP连接里的HTTP请求都必须等待这个丢了的包被重传回来。

- HTTP/1.1管道传输：一个请求阻塞，则队列后请求也被阻塞
- HTTP/2多路复用：一旦发生丢包，所有HTTP请求被阻塞

均为基于TCP基于传输层的问题，所以HTTP/3把TCP改为了UDP

**如何保证可靠？**

![img](https://upload-images.jianshu.io/upload_images/6301972-9482e8b53c342058.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

QUIC协议：用于实现可靠传输

- QUIC有自己的一套保证可靠传输的机制，当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响
- HTTPS建立一个连接，需要进行6次交互（TCP三握手，TLS三握手），QUIC把他们合并成了三次。



# TCP

## 一、TCP的基本认识

### TCP首部格式

![image-20210830213825325](C:\Users\联想\AppData\Roaming\Typora\typora-user-images\image-20210830213825325.png)

**序列号：**在建立连接时由计算机生成的随机数作为初始值，用来解决网络包乱序问题。

**确认应答号：**指下一次期望收到的数据的序列号，发送端收到这个确认应答后可以认为在这个序列号之前的数据都已被正常接收，用来解决不丢包问题。

**控制位：**

- ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。 
- RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。 
- SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。 
- FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主 机之间就可以相互交换 FIN 位为 1 的 TCP 段。

### TCP和UDP的区别，分别的应用场景

UDP 不提供复杂的控制机制，利⽤ IP 提供⾯向「⽆连接」的通信服务。 UDP 协议真的⾮常简，头部只有 8 个字节（ 64 位），UDP 的头部格式如下：

![image-20210830214609120](C:\Users\联想\AppData\Roaming\Typora\typora-user-images\image-20210830214609120.png)

- ⽬标和源端⼝：主要是告诉 UDP 协议应该把报⽂发给哪个进程。 
- 包⻓度：该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和。 
- 校验和：校验和是为了提供可靠的 UDP ⾸部和数据⽽设计

**区别：**

1. 连接：

   TCP是面向连接的传输层协议，传输数据前先建立连接。
   UDP是不需要先建立连接，即刻传输数据。

2. 服务对象

   TCP是一对一的两点服务。
   UDP支持一对一，一对多，多对多的交互通信。

3. 可靠性

   TCP是可靠交付数据，保证无差错，不重复，不丢失，按顺序。
   UDP的尽最大努力交付，不保证可靠。

4. 拥塞控制、流量控制

   TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
   UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。

5. 首部开销

   TCP首部最少20字节，如果使用了“选项”字段，则会更长。
   UDP首部固定8字节。

6. 传输方式

   TCP是流式传输，没有边界。
   UDP是一个包一个包的发送，有边界。

7. 分片不同：

   - TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。 
   - UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再 传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要᯿传所有的数据包，这样传输 效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。

**应用场景：**

由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于： 
FTP ⽂件传输 
HTTP / HTTPS 

由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于： 
包总量较少的通信，如 DNS 、 SNMP 等 
视频、⾳频等多媒体通信 
广播通信

### MTU和MSS

![image-20210830220338916](C:\Users\联想\AppData\Roaming\Typora\typora-user-images\image-20210830220338916.png)

MTU：一个网络包的最大长度。以太网中一般为1500字节。
MSS：除去IP头部和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度。

**如果在TCP的整个报⽂（头部+数据）交给IP层进行分片，会有什么异常呢？**

当 IP 层有⼀个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进⾏分⽚，把数据分⽚成若⼲⽚，保证每⼀个分⽚都⼩于 MTU。把⼀份 IP 数据报进⾏分⽚以后，由⽬标主机的 IP 层来进⾏᯿新组装后，再交给上⼀层 TCP 传输层。

这看起来井然有序，但这存在隐患的，那么当如果⼀个 IP 分⽚丢失，整个 IP 报⽂的所有分⽚都得重传。

因为 IP 层本身没有超时᯿传机制，它由传输层的 TCP 来负责超时和重传。

当接收⽅发现 TCP 报⽂（头部 + 数据）的某⼀⽚丢失后，则不会响应 ACK 给对⽅，那么发送⽅的 TCP 在超时后，就会重发「整个 TCP 报⽂（头部 + 据）」。

因此，可以得知由 IP 层进⾏分⽚传输，是⾮常没有效率的。

所以，为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双⽅的 MSS 值，当 TCP 层发现数据超过MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，⾃然也就不⽤ IP 分片了。

经过 TCP 层分⽚后，如果⼀个 TCP 分⽚丢失后，进⾏重发时也是以 MSS 为单位，⽽不⽤重传所有的分片，大大增加了重传的效率。

## 二、TCP建立连接

## 三、TCP断开连接

